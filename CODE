
####预测缺口
library(ggplot2)
data <- read.csv("/Users/peisiyuan/BENV0093-FINAL/0093projectiondata.csv")
head(data)

data$GDP=data$GDP/1000000
data$Population=data$Population/1000000
data$percapita=data$GDP/data$Population
traindata=data[1:50,1:5]
#model <- lm(Electricpowerconsumptionperc ~ GDP + Population, data = traindata)
model <- lm(Electricpowerconsumptionperc ~ percapita, data = traindata)
summary(model)
new_data <- data[51:60,-3]
predicted_electricity_consumption <- predict(model, newdata = new_data)

k=read.csv("/Users/peisiyuan/BENV0093-FINAL/0093projectiondata.csv")
k2=k[1:50,1:4]
k3=k[51:60,-3]
predict=c(predicted_electricity_consumption*k3$Population)
plot <- data.frame(
  Year = k$time,
  Historical = c(k2$Electricpowerconsumptionperc*k2$Population/10^9,rep(NA, 10)),
  Predicted = c(rep(NA, 50),predict/10^9)
)

###2030能源需求：TWH
plot$Predicted[plot$Year=='2030']
###太阳能总发电量：TWH
plot$Predicted[plot$Year=='2030']*0.38
###



cap_all=read.csv("/Users/peisiyuan/BENV0093-FINAL/BENV0093_2ndAssignment_powerplants.csv")
solarpower=c(cap_all$capacity)
solarpower=as.numeric(solarpower)

all_solarpower=sum(solarpower)
gap=(0.38*(plot$Predicted[plot$Year=='2030']/0.3702*1000000/(365*24))-all_solarpower)/1000##GW
gap

ggplot(data = plot, aes(x = Year)) +
  geom_line(aes(y = Historical), color = "blue") +
  geom_line(aes(y = Predicted), color = "red", linetype = "dashed") +
  labs(
    x = "Year",
    y = "Electric power consumption(TWh)") +
  theme_minimal()

GDProjection<- data.frame(
  Year = k$time,
  Historical = c(k2$GDP/10^9,rep(NA, 10)),
  Predicted = c(rep(NA, 50),k3$GDP/10^9)
)
ggplot(data =GDProjection , aes(x = Year)) +
  geom_line(aes(y = Historical), color = "blue") +
  geom_line(aes(y = Predicted), color = "red", linetype = "dashed") +
  labs(
    x = "Year",
    y = "GDP(constant 2015 US$ million)") +
  theme_minimal()

Populationrojection<- data.frame(
  Year = k$time,
  Historical = c(k2$Population/10^9,rep(NA, 10)),
  Predicted = c(rep(NA, 50),k3$Population/10^9)
)
ggplot(data =Populationrojection , aes(x = Year)) +
  geom_line(aes(y = Historical), color = "blue") +
  geom_line(aes(y = Predicted), color = "red", linetype = "dashed") +
  labs(
    x = "Year",
    y = "Population (million)") +
  theme_minimal()

###############################
####筛选地区
getwd()
install.packages('pacman')
install.packages('ncdf4')
install.packages('chron')
library(pacman)
library(terra)
p_load(sf)

indonesia<- st_read("/Users/peisiyuan/BENV0093-FINAL/idn_adm_bps_20200401_shp/idn_admbnda_adm0_bps_20200401.shp")
raster_template = rast(resolution = 0.05,
                        xmin=95.01079 , ymin=-11.00762  ,xmax=141.01940 , ymax=6.0769,crs = st_crs(indonesia)$wkt)
raster_template

#太阳辐射
library(ncdf4)
era <- nc_open("/Users/peisiyuan/BENV0093-FINAL/data.nc" )
era 
lon <- ncvar_get(era, "longitude")
lat <- ncvar_get(era, "latitude")
time <- ncvar_get(era, "time")
time
dim(time) 
tunits <- ncatt_get(era,"time","units")

library(chron)
tustr <- strsplit(tunits$value, " ") #strsplit: split the element of character vector. we can convert  "hours since 1900-01-01" to "hours"      "since"      "1900-01-01"
tdstr <- strsplit(unlist(tustr)[3], "-") #convert "1900-01-01" to "1900" "01"   "01"
tyear <- as.integer(unlist(tdstr)[1]) 
tmonth <- as.integer(unlist(tdstr)[2])
tday <- as.integer(unlist(tdstr)[3])

chron(time/24, origin=c(tmonth, tday, tyear) )
ssrd_array <- ncvar_get(era,"ssrd") #get the Surface solar radiation downwards
dim(ssrd_array)
dlname <- ncatt_get(era,"ssrd","long_name")
dunits <- ncatt_get(era,"ssrd","units")
fillvalue <- ncatt_get(era,"ssrd","_FillValue")

library(lattice)
library(RColorBrewer)


#Get a single time slice of the data using ssrd_array
ssrd_slice <- ssrd_array[,] 
#The ssrd_slice is actually a matrix. class(ssrd_slice)
# What does 2 in ssrd_array[,,2] indicate?  What if I want to slice all four time slice for "07/01/19"? 
length(na.omit(as.vector(ssrd_slice))) /length(as.vector(ssrd_slice))
dim(ssrd_slice )
image(ssrd_slice, col=rev(brewer.pal(10,"RdBu")) )
lonlat <- as.matrix( (expand.grid(lon, lat))) #lon and lat are what we extracted in step 2.
dim(lonlat)
ssrd_vec <- as.vector( ssrd_slice) 
length(ssrd_vec)
ssrd_df <- data.frame( cbind( lonlat,ssrd_vec  ))
colnames(ssrd_df) <- c("lon", "lat", "ssrd")
ssrd_df_value <- na.omit (ssrd_df)
head(ssrd_df_value, 3) 
library(sf)
ssrd_sf<- st_as_sf( ssrd_df_value, coords = c(  "lon", "lat")  ) #convert long and lat to point in simple feature format
#To make it a complete geographical object we assign the WGS84 projection, which has the EPSG code 4326
st_crs(ssrd_sf) <- 4326 
ssrd_sf <- st_transform(ssrd_sf, 4326 )
head(ssrd_df_value)
head(ssrd_sf)

###完成ssrd_sf

library(tmap)
tmap_mode("view")
tm_shape(ssrd_sf)+
  tm_dots(col="ssrd", style = "quantile", size=.001, palette = "viridis")
ncatt_get(era,"ssrd","units")

radiation_to_power <- function(G, A=1, r=0.175, p=0.6, hours=1){
  kWh <- G * A * r * p * (hours/3600) / 1000
  return(kWh)
}

ssrd_kwh <- as.data.frame (radiation_to_power (ssrd_df_value))
ssrd_df_value <- cbind(ssrd_df_value,ssrd_kwh$ssrd)
colnames(ssrd_df_value) [4] <- 'ssrd_kwh'
ssrd_sf$ssrd_kwh = ssrd_kwh$ssrd
tm_shape(ssrd_sf)+
  tm_dots(col="ssrd_kwh", style = "quantile", size=.001, palette = "YlOrRd")

############

library(gstat) #geostatistics used for interpolation. More details can be found [https://cran.r-project.org/web/packages/gstat/gstat.pdf] 
#https://www.gstat.org/gstat.pdf see Section 2.3
library(rgdal)
library(tmap)
library(terra)

ssrd_sf = st_transform(ssrd_sf, 4326)
indonesia = st_transform(indonesia, st_crs(ssrd_sf))
coor = as.data.frame(st_coordinates(ssrd_sf))
head(coor)
ssrd_sf$x = coor$X
ssrd_sf$y = coor$Y
ssrd_nogeom = st_drop_geometry(ssrd_sf) #get rid of geometry but keep all other attributes
head(ssrd_nogeom )
ssrd_nogeom=na.omit(ssrd_nogeom)
gs <- gstat(formula=ssrd_kwh~1, locations=~x+y, data=ssrd_nogeom, nmax=Inf, set=list(idp=2)) #data should be in data frame format
gs
st_bbox(indonesia)
raster_template = rast(resolution = 0.05,
                        xmin=95.010799 , ymin=-11.00762  ,xmax=141.01940 , ymax=6.07693  ,  crs = st_crs(indonesia)$wkt)
raster_template #check basic information about the raster template we created
idw <- interpolate(raster_template, gs, debug.level=0) #interpolate is the function comes with terra
plot(idw$var1.pred)
idw_mask <- mask(idw, indonesia)
plot(idw_mask$var1.pred)
names(idw_mask) = c( "ssrd_kwh","observed" )
tmap_mode("view")
tm_shape(idw_mask$ssrd_kwh) + 
  tm_raster(col="ssrd_kwh", style = "quantile", n = 4, palette= "Blues", legend.show = TRUE)
###检验
RMSE <- function(observed, predicted) {
  sqrt(mean((predicted - observed)^2, na.rm=TRUE))
}
null <- RMSE(mean(ssrd_sf$ssrd_kwh), ssrd_sf$ssrd_kwh)
null #1.656786 is the baseline. 

###标准
###
summary(idw_mask$ssrd_kwh)

ssrd_matrix<- matrix(c( 0.5,0.6,1,  
                         0.45,  0.5,3/4,   
                        0.42,0.45,  2/4,                   
                        0.29,   0.42, 1/4), ncol=3, byrow=TRUE) 
idw_mask_binary<- classify(idw_mask, ssrd_matrix, include.lowest=TRUE )
tm_shape(idw_mask_binary$ssrd_kwh) + 
  tm_raster(style = "cat", palette ="YlGn",alpha=.4)


#######海拔###############################
library(terra)
library(rgdal)
elevation<-rast('/Users/peisiyuan/BENV0093-FINAL/IDN_alt/IDN_alt.vrt')
plot(elevation, col = brewer.pal(9, "YlOrRd"))

elevation_masked=mask(elevation, indonesia)
tm_shape(elevation_masked$IDN_alt) + 
  tm_raster(style = "quantile", n = 4, palette= "plasma", legend.show = TRUE)
  
##筛选
elevation_matrix<- matrix(c( 425, 4650,1,  
                        100,  425,3/4,   
                        27,100,  2/4,                   
                        -103, 27, 1/4), ncol=3, byrow=TRUE) 
elevation_binary<- classify(elevation, elevation_matrix, include.lowest=TRUE )

elevation_binary_masked=mask(elevation_binary, indonesia)

##画图
tm_shape(elevation_binary_masked) +
  tm_raster(style = "cat", palette = 'plasma',alpha=.4)
  

#######人口###############################
population<-rast('/Users/peisiyuan/BENV0093-FINAL/IDN_pop/idn_pop.vrt')
##人口标准##
population_masked=mask(population,indonesia)
tm_shape(population_masked$idn_pop) + 
  tm_raster(style = "quantile", n = 4, palette= "YlOrRd", legend.show = TRUE)

pop_matrix<- matrix(c(0, 10,  1,  
                      10, 100, 0.8,   
                      100, 1000, 0.6,                   
                      1000, 10000, 0.4,        
                      10000, 100000, 0.2), ncol=3, byrow=TRUE) 
population_binary<- classify(population, pop_matrix, include.lowest=TRUE )
##画图######
library(raster) 
population_masked=raster(mask(population_binary, indonesia))
tm_shape(population_masked$idn_pop) +
  tm_raster(style = "cat", palette =  "YlOrRd",alpha=.5)


#######植被覆盖###############################
landcover<-rast('/Users/peisiyuan/BENV0093-FINAL/IDN_cov/IDN_cov.vrt')
##看标准(调整土地类型，参考glc2000)https://zhuanlan.zhihu.com/p/485507326
landcover_binary<-landcover %in%c(5, 6, 7, 8, 10, 12, 18, 19, 20, 21, 22)
###去除森林、农业用地和
landcover_masked=raster(mask(landcover_binary, indonesia))

tm_shape(landcover_masked$IDN_cov==1) +
  tm_raster(style = "pretty", palette =  "Blues",n=2,legend.show = TRUE)


#######水源###############################
###合并line和area
water_AREA<- st_read("/Users/peisiyuan/BENV0093-FINAL/IDN_wat/IDN_water_areas_dcw.shp")
water_LINE<- st_read("/Users/peisiyuan/BENV0093-FINAL/IDN_wat/IDN_water_lines_dcw.shp")
print(names(water_AREA))
print(names(water_LINE))
names(water_LINE)[which(names(water_LINE)=='NAM')]='NAME'
names(water_LINE)[which(names(water_LINE)=='NAME_0')]="COUNTRY"
water=rbind(water_LINE,water_AREA)
###栅格化印尼
install.packages("rgeos")
library(terra)
library(rgeos)
library(raster) 
raster_indonesia<- rast(indonesia,resolution = 0.1)
river_lines <- st_collection_extract(water, "LINESTRING")
water_data_spatial <- as_Spatial(river_lines)
water_data_spatvector <- vect(water_data_spatial)
distances <- distance(raster_indonesia, water_data_spatvector)
#####标准
hist(distances$lyr.1)
max(distances$lyr.1)

distances_masked=mask(distances, indonesia)
tm_shape(distances_masked$lyr.1) + 
  tm_raster(style = "quantile", n = 4, palette= "YlGnBu", legend.show = TRUE)

water_matrix<- matrix(c(0, 5000,  1,  
                      5000, 10000, 3/4,   
                      10000, 150000, 2/4,                   
                      150000, 1000000,1/4), ncol=3, byrow=TRUE) 

distances_binary= classify(distances,water_matrix, include.lowest=TRUE )

distances_binary_masked=mask(distances_binary, indonesia)
tm_shape(distances_binary_masked$lyr.1) +
  tm_raster(style = "cat",palette = "YlGnBu",alpha=.4)

######道路###############################
library(dplyr)
road<- st_read("/Users/peisiyuan/BENV0093-FINAL/IDN_rds/IDN_roads.shp")
trainline<- st_read("/Users/peisiyuan/BENV0093-FINAL/IDN_rrd/IDN_rails.shp")
#筛选合并
road<- road %>% select(c("F_CODE_DES", "ISO", "ISOCOUNTRY", "geometry"))
trainline=trainline %>% select(c("F_CODE_DES", "ISO", "ISOCOUNTRY", "geometry"))
all_road<- rbind(road, trainline)

road_data_spatial <- as_Spatial(all_road)
road_data_spatvector <- vect(road_data_spatial)
distances_road<- distance(raster_indonesia, road_data_spatvector)

distances_road_masked=mask(distances_road, indonesia)
tm_shape(distances_road_masked$lyr.1) + 
  tm_raster(style = "quantile", n = 4,  legend.show = TRUE)

road_matrix<- matrix(c(0, 1500,  1,  
                        1500, 5000, 3/4,   
                        5000, 7500, 2/4,                   
                        7500, 1000000,1/4), ncol=3, byrow=TRUE) 
distances_road_binary= classify(distances_road,road_matrix, include.lowest=TRUE )
distances_road_binary_masked=mask(distances_road_binary, indonesia)
tm_shape(distances_road_binary_masked$lyr.1) +
  tm_raster(style = "cat",palette = "PuRd",alpha=.4)

######电网###############################
install.packages('osmdata')
library(osmdata)
library(tmap)
library(sf)
#step 1 define query area by bbox
coords<-matrix(c(95.01079,141.01940,-11.00762, 6.07693),byrow = TRUE,nrow =2,ncol = 2, dimnames = list(c('x','y'),c('min','max')))
location <- opq(coords)
#step 2 search features of interests
powerplant = add_osm_feature(location, key = 'power', value = 'line')
powerplant.sf <- st_read("/Users/peisiyuan/BENV0093-FINAL/grid.geojson")
#powerplant.sf = osmdata_sf(powerplant)
tm_shape(powerplant.sf$geometry)+tm_lines(col= "red")

transmission_line=powerplant.sf$geometry
transmission_line_data_spatial <- as_Spatial(transmission_line)
transmission_line_data_spatvector <- vect(transmission_line_data_spatial)
transmission_line_data_sf <- st_as_sf(transmission_line_data_spatvector)
transmission_line_data_sf_transformed <- st_transform(transmission_line_data_sf, st_crs(raster_indonesia))
transmission_line_data_spatvector_transformed <- as(transmission_line_data_sf_transformed, "SpatVector")
distances_transmission<- distance(raster_indonesia, transmission_line_data_spatvector_transformed )

distances_transmission_masked=mask(distances_transmission, indonesia)
tm_shape(distances_transmission_masked$lyr.1) + 
  tm_raster(style = "quantile", n = 4, palette = "Set1", legend.show = TRUE)
summary(distances_transmission_masked$lyr.1)

transmission_matrix<- matrix(c(0, 1000,  1,  
                       1000, 5000, 3/4,   
                       5000, 10000, 2/4,                   
                       10000, 663161,1/4), ncol=3, byrow=TRUE) 
distances_transmission_binary= classify(distances_transmission,transmission_matrix, include.lowest=TRUE )
distances_transmission_binary_masked=mask(distances_transmission_binary, indonesia)
tm_shape(distances_transmission_binary_masked$lyr.1) +
  tm_raster(style = "cat",palette = "Set1",alpha=.4)
###########读取保护区
protection_point<- st_read("/Users/peisiyuan/BENV0093-FINAL/protection/WDPA_WDOECM_Apr2023_Public_IDN_shp-points.shp")
protection_area<- st_read("/Users/peisiyuan/BENV0093-FINAL/protection/WDPA_WDOECM_Apr2023_Public_IDN_shp-polygons.shp")
protection_area=select(protection_area, -GIS_M_AREA, -GIS_AREA)
#all_protection<- rbind(protection_area, protection_point)
all_protection<- protection_area
all_protection_1=all_protection$geometry
all_protection_1<- st_transform(all_protection_1, st_crs(indonesia))
all_protection_1<- st_cast(all_protection_1, "MULTIPOLYGON")



####调整分辨率 将所有的都调整成extent为95.01079, 141.0108, -11.00762, 6.092385  (xmin, xmax, ymin, ymax)，分辨率为0.1的对象
new_raster <- rast(nrow = 171, ncol = 460, xmin = 95.01079, xmax = 141.0108, ymin = -11.00762, ymax = 6.092385, crs = "EPSG:4326")
###海拔
elevation_binary_masked_new <- resample(elevation_binary_masked, new_raster)
###人口密度
population_masked_new <- resample(rast(population_masked), new_raster)
###植被覆盖
##landcover_masked_new<- resample(rast(landcover_masked), new_raster)
###辐照水平
idw_mask_new=resample(idw_mask_binary$ssrd_kwh, new_raster)
idw_mask_new_data=resample(idw_mask$ssrd_kwh, new_raster)
####植被覆盖
landcover_new=resample(rast(landcover_masked$IDN_cov), new_raster)
#vector_data_landcover_new <- rasterToPolygons(raster(landcover_new))
#vector_data_sf_landcover_new <- st_as_sf(vector_data_landcover_new)
#st_write(vector_data_sf_landcover_new, "landcover_new.shp")


result=(1/15*elevation_binary_masked_new$IDN_alt+0.1*population_masked_new$idn_pop+
            2/15*distances_road_binary_masked$lyr.1+1/6*distances_binary_masked$lyr.1+
            0.2*distances_transmission_binary_masked$lyr.1+1/3*idw_mask_new$ssrd_kwh)
tm_shape(result$IDN_alt) +
  tm_raster(style = "pretty", palette = "Blues", n=3,legend.show = TRUE)
####权重###根据权重计算#####植被覆盖为0的话不用
result_1=(1/15*elevation_binary_masked_new$IDN_alt+0.1*population_masked_new$idn_pop+
  2/15*distances_road_binary_masked$lyr.1+1/6*distances_binary_masked$lyr.1+
  0.2*distances_transmission_binary_masked$lyr.1+1/3*idw_mask_new$ssrd_kwh)*landcover_new$IDN_cov
###加上保护区
all_protection_1_sp <- as(all_protection_1, "Spatial")
all_protection_1_sf <- sf::st_as_sf(all_protection_1_sp)
tm_shape(all_protection_1_sf) +
  tm_polygons(border.col = "black", border.alpha = 1, title = "Protection Area") +
  tm_layout(main.title = "Protected Areas")
all_protection_1_spatvector <- vect(all_protection_1)

result_1_new<-mask(result_1, indonesia)

result_1_new_diff <- mask(result_1_new, all_protection_1_spatvector, inverse = TRUE)


tm_shape(result_1_new_diff$IDN_alt) +
  tm_raster(style = "pretty", palette = "Reds", n=4,legend.show = TRUE)

#组合在一起
combined<- c(distances_transmission_masked$lyr.1, result_1_new_diff$IDN_alt,idw_mask_new_data$ssrd_kwh*(12*1000*1000)*0.2/1000/1000*3)

combined_df <- as.data.frame(combined, xy = TRUE)
top_values <- head(combined_df[order(-combined_df$IDN_alt), ], 12)
sum(top_values$ssrd_kwh)
sum(top_values$lyr.1)/1000*3

selected_coordinates <- top_values[, c("x", "y")]

selected_coordinates_sf <- st_as_sf(selected_coordinates,coords = c("x", "y"), crs = st_crs(indonesia))
# 提取12个坐标对应的栅格值


tm_shape(selected_coordinates_sf) +
  tm_dots(col = "red", size = 0.02) +
  tm_layout(title = "seleced solar station place", legend.position = "none")
#海拔：人口密度：到路距离：到水源距离：到电网距离：发电效率=2:3:4:5:6:10
#假设权重=海拔、人口密度、到路距离、到水源距离、到电网距离、发电效率=1/15、1/10、2/15、1/6、1/5、1/3

#根据CR检验权证
##########海拔、人口密度、到路距离、到水源距离、到电网距离、发电效率

A <- matrix(c(1,  3/2,  2,  5/2,  3,  5,
              2/3,1,  4/3,5/3,6/3,10/3,
              2/4,3/4,1,  5/4,  6/4,5/2,
              2/5,3/5,4/5,  1,  6/5,10/5,
              2/6,3/6,4/6,5/6,1,  10/6,
              2/10,3/10,2/5,5/10,6/10,1), nrow = 6, ncol = 6, byrow = TRUE)

##这里比错了，所以转制了一下
# 计算特征值和特征向量
eigen(t(A))
k=6
RI=1.24
CI=((6-6)/5)
CR=CI/RI=0

####NPV###



capex_network=sum(top_values$lyr.1)*3/1000*sum(top_values$ssrd_kwh)*590/1000000#$
capex_capacity=sum(top_values$ssrd_kwh)*1.16#$
capex=capex_capacity+capex_network
annual_revenue=sum(top_values$ssrd_kwh)*103*365*24*0.24/1000000

#2 Net Present Value (NPV)======
rep(10,4) #create a vector by repeating 10 4 times
# output of the function above is: 10 10 10 10
seq( 1, 11, 2) #create a sequence of data start from 1 and end at 11. 2 is the increment of the sequence.
#outout will be: 1 3 5 7 9 11

calc_NPV <- function(annual_revenue, i=0.05, lifetime_yrs, CAPEX, OPEX=0){
  costs_op <- rep(OPEX, lifetime_yrs) #operating cost
  revenue <- rep(annual_revenue, lifetime_yrs) 
  t <- seq(1, lifetime_yrs, 1) #output: 1, 2, 3, ...25
  
  NPV <- sum( (revenue - costs_op)/(1 + i)**t ) - CAPEX
  return(round(NPV, 0))
}
#Exercise: if annual revenue is 14000000, and Capital expenditure is 150000000, then please calculate Net present value. Should we invest this project?


npv=calc_NPV(annual_revenue,lifetime_yrs=25,CAPEX=capex)
ifelse(npv>0, "Support","obeject" )

#3 Levelized cost of electricity (LCOE)=====
#Life_span_generation_kWH is one of the required inputs to estimate the Levelized
#cost of electricity (following function)
Life_span_generation_kWH <- function (yearly_generation_kWH, discount = 0.03, lifetime_yrs = 25){
  t<- seq(1, lifetime_yrs, 1)
  L_S_G <- sum(yearly_generation_kWH/(1+discount)**t)
  return (round(L_S_G,0))
}

LCOE <- function(NPV,Life_span_generation){
  lcoe <- NPV/Life_span_generation
  return(round(lcoe,2))
}
yearly_generation_kWH=sum(top_values$ssrd_kwh)*365*24*0.24
lsg=Life_span_generation_kWH(yearly_generation_kWH)
l=LCOE(npv1*1000000,lsg)
